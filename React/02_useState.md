# useEffect 정리

---

## 1. 언제 쓰는지 / 왜 쓰는지

- React 컴포넌트는 기본적으로 **순수 함수처럼 동작**해야 함 (입력 → 출력만).
- 하지만 현실적으로는 외부 세계와 상호작용이 필요 → 이게 바로 **사이드 이펙트(Side Effect)**.
- `useEffect`는 이런 부수 효과를 **렌더링 이후 안전하게 실행**하기 위한 훅.
- 대표 상황: API 요청, DOM 조작, 타이머, 로컬 스토리지 접근 등.

---

## 2. 기본 사용법

```js
useEffect(() => {
  // 실행할 사이드 이펙트
  return () => {
    // 정리(clean-up) 필요하면 작성
  };
}, [dep1, dep2]);
```

- **의존성 배열** → 값이 바뀔 때마다 실행. 빈 배열 `[]`이면 처음 한 번만 실행.
- **정리 함수** → 컴포넌트가 사라지거나, 다음 이펙트 실행 전에 실행됨.

---

## 3. 확장된 사용법

### 3-1. DOM 조작 동기화

```js
useEffect(() => {
  document.title = title; // title 상태와 동기화
}, [title]);
```

→ 여러 곳에서 중복 코드 없이, 상태와 외부 DOM 속성을 자동 동기화 가능.

---

### 3-2. 네트워크 요청

```js
useEffect(() => {
  fetch("https://example.com/data")
    .then((res) => res.json())
    .then((body) => setData(body));
}, []);
```

→ 컴포넌트가 처음 렌더링될 때 데이터 불러오기.

---

### 3-3. 타이머 + 정리 함수

```js
useEffect(() => {
  const id = setInterval(() => {
    setSecond((s) => s + 1);
  }, 1000);

  return () => clearInterval(id); // 컴포넌트 사라질 때 정리
}, []);
```

→ 메모리 누수나 중복 실행을 막기 위해 cleanup 필수.

---

### 3-4. 브라우저 저장소

```js
useEffect(() => {
  localStorage.setItem("theme", theme);
}, [theme]);
```

→ 상태와 로컬 스토리지 값 동기화.

---

## 4. 체크리스트

- [ ] 함수 본문 안에서 사이드 이펙트를 직접 실행하지 않았는가? (렌더링 중 실행 금지)
- [ ] 이펙트가 의존하는 state/props를 배열에 다 넣었는가?
- [ ] 반복되는 동기화 로직을 useEffect로 추출했는가?
- [ ] 메모리 점유(타이머, 이벤트 리스너 등)는 cleanup 함수에서 해제했는가?
- [ ] 네트워크 요청, DOM 조작, 로컬 스토리지는 useEffect 안에서 처리했는가?

---

## 5. 트러블슈팅

- “계속 무한 호출돼요” → 의존성 배열 확인 (빠진 값이나 불필요한 값 있는지 점검).
- “값이 최신이 아니에요” → 필요한 state/prop이 배열에 누락된 경우.
- “타이머/리스너 중복 실행돼요” → cleanup 함수 누락.
- “처음 한 번만 실행하고 싶어요” → `[]` 빈 배열 사용.

---
