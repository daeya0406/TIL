# ⚡ useEffect 정리

---

## 1. 언제 쓰는지 / 왜 쓰는지

- **렌더링 이후 실행해야 하는 코드**를 넣을 때 사용
- React는 렌더링 중에 DOM을 바꾸면 에러가 날 수 있어서, 사이드 이펙트(부수 효과)는 `useEffect` 안에 둬야 함
- 예시:
  - API 호출 (데이터 불러오기)
  - 이벤트 리스너 등록/해제
  - 타이머 실행
  - DOM 조작 (스크롤, 포커스 등)

---

## 2. 기본 사용법

### 2-1. 처음 한 번만 실행

컴포넌트가 마운트될 때만 실행 → 디펜던시 배열 `[]` 사용

```js
useEffect(() => {
  console.log("처음 한 번만 실행");
}, []);
```

### 2-2. 값이 바뀔 때마다 실행

특정 상태나 props가 바뀔 때마다 실행

```js
useEffect(() => {
  console.log("count가 바뀔 때마다 실행");
}, [count]);
```

---

## 3. 확장된 사용법

### 3-1. 정리(clean-up) 함수

이벤트 리스너 제거, 타이머 정리 등은 `return`으로 처리

```js
useEffect(() => {
  const id = setInterval(() => {
    console.log("타이머 동작 중");
  }, 1000);

  return () => {
    clearInterval(id);
    console.log("타이머 정리 완료");
  };
}, []);
```

### 3-2. 여러 상태 의존

배열 안에 여러 값 넣으면, 그 중 하나라도 바뀔 때 실행

```js
useEffect(() => {
  console.log("first 또는 second가 바뀜");
}, [first, second]);
```

---

## 4. 체크리스트

- [ ] 이 코드가 렌더링 중 실행되면 안 되나? → 그렇다면 `useEffect`
- [ ] 특정 값이 바뀔 때만 실행돼야 하나? → 디펜던시 배열에 값 추가
- [ ] 클린업(clean-up)이 필요한가? → `return () => { ... }` 작성
- [ ] 디펜던시 배열 빼먹지 않았는가? (ESLint 경고 확인)

---

## 5. 트러블슈팅

- “계속 무한 실행돼요” → 디펜던시 배열을 잘못 설정했을 가능성 있음
- “값이 최신이 아니에요” → 디펜던시 배열에 필요한 상태/props가 빠졌을 수 있음
- “이벤트가 중복 등록돼요” → clean-up 함수 누락 확인
- “처음에만 실행하고 싶어요” → `[]` 빈 배열 넣기

---
