# 자바스크립트 동등 비교와 리액트 렌더링

---

## 1. 언제 쓰는지 / 왜 쓰는지

- 리액트에서 **컴포넌트 리렌더링 여부**는 props 비교 결과에 따라 달라짐
- 이 비교는 **얕은(shallow) 동등 비교**를 기반으로 이루어짐
- 동등 비교의 원리를 이해해야:
  - `useEffect` 의존성 배열에 무엇을 넣어야 하는지 감이 옴
  - `useMemo`, `useCallback`, `React.memo` 같은 최적화 도구를 올바르게 사용할 수 있음

---

## 2. 기본 사용법 (자바스크립트 동등 비교)

### 원시 타입 vs 객체 타입

- **원시 타입**: 값 자체가 저장됨 → 값만 같으면 같다고 판단
- **객체 타입**: 참조(reference)로 저장됨 → 같은 구조라도 메모리 주소 다르면 다르다고 판단

```js
// 원시 타입
1 === 1;           // true
"hi" === "hi";     // true

// 객체 타입
{} === {};         // false (주소가 다름)
[1,2] === [1,2];   // false
```

### Object.is

- `===` 와 유사하지만 몇 가지 특별 케이스를 다르게 처리
- 리액트는 내부적으로 **Object.is + 얕은 비교**를 사용

```js
Object.is(NaN, NaN); // true  (===는 false)
Object.is(+0, -0); // false (===는 true)
```

---

## 3. 확장된 사용법 (리액트와의 연결)

- **props 비교 → 렌더링 여부 결정**
  - `React.memo` 는 얕은 비교로 props 변경 여부 확인
  - 객체/배열/함수는 매번 새로 생성되면 다른 값으로 판단 → 불필요한 렌더 발생 가능
- **useEffect 의존성 배열**
  - 내부적으로 동등 비교로 값이 달라졌는지 판단
  - 의존성 배열 잘못 작성하면, effect가 너무 자주 실행되거나 실행 안 됨
- **useMemo / useCallback**
  - 참조형 값(객체/함수 등)이 매번 새로 만들어지는 문제를 해결하기 위해 사용

---

## 4. 체크리스트

- [ ] 원시 타입은 값 비교, 객체는 참조 비교라는 점을 기억했는가?
- [ ] 리액트의 비교 방식은 `Object.is` + 얕은 비교라는 점을 알고 있는가?
- [ ] 불필요한 렌더링을 막으려면 `useMemo`, `useCallback`, `React.memo`를 적절히 쓰고 있는가?
- [ ] 의존성 배열을 채울 때 **eslint-plugin-react-hooks** 규칙을 따르고 있는가?

---
